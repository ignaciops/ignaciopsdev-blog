---
title: 'Arquitectura Hexagonal en Testing: Separar el QU√â del C√ìMO'
date: 2026-01-27T23:51:00.000Z
coverImage: >-
  /images/posts/covers/arquitectura-hexagonal-en-testing-separar-el-que-del-como/coverImage.png
coverImageAttribution: Imagen generada mediante IA con ChatGPT Im√°genes.
summary: >-
  Qu√© aprend√≠ aplicando arquitectura hexagonal en testing y c√≥mo cambi√≥ mi forma
  de pensar sobre E2E, ports y adapters.
metaDescription: >-
  Reflexi√≥n pr√°ctica sobre arquitectura hexagonal aplicada al testing: c√≥mo
  separar el qu√© del c√≥mo y repensar el uso de pruebas E2E.
tags:
  - roadmap-2026
  - arquitectura-de-pruebas
  - aprendizaje
  - ports-and-adapters
  - arquitectura-hexagonal
featured: true
---
> Este post corresponde al primer m√≥dulo del roadmap: Foundations + Arquitectura Hexagonal, donde el objetivo no era cubrir herramientas, sino sentar las bases de c√≥mo quiero pensar y dise√±ar sistemas de pruebas durante el a√±o.

---

Una de las preguntas m√°s comunes cuando se habla de automatizaci√≥n de pruebas es: ¬øQu√© pruebas debemos automatizar?

La respuesta cl√°sica tiende a ser: "las que son repetitivas, consumen bastante tiempo y son cr√≠ticas para el negocio". El problema aparece cuando esa respuesta se interpreta como "todo es cr√≠tico", y se intenta automatizar absolutamente todo.

Es en ese punto donde las pruebas E2E dejan de ser pocas, enfocadas y estrat√©gicas, y se convierten en suites enormes que intentan cubrir todos los casos de uso. El resultado suele ser el mismo: ejecuciones lentas, alto costo de mantenimiento y una inversi√≥n considerable de tiempo y recursos para obtener retroalimentaci√≥n tard√≠a.

Ahora imagina que tu framework de pruebas est√° dise√±ado de tal manera que puedas validar edge cases (errores de √≠ndice, validaciones de negocio, flujos inv√°lidos) en segundos, sin levantar un navegador y sin depender de una herramienta espec√≠fica. Que puedas probar la l√≥gica de tus escenarios de forma aislada y r√°pida.&#x20;

Eso es parte de lo que aprend√≠ este primer mes del roadmap de aprendizaje que estoy siguiendo, donde estoy aplicando Arquitectura Hexagonal a un framework de pruebas.

Durante el 2026 estar√© profundizando en arquitectura hexagonal aplicada a testing, as√≠ como en distintos aspectos del aseguramiento de calidad que he utilizado de forma parcial, pero que necesito dominar con mayor profundidad, y otros que a√∫n no he tenido oportunidad de aplicar, como contract testing y chaos engineering. Si quieres conocer por qu√© eleg√≠ esta arquitectura, sus conceptos base y el alcance completo del roadmap, puedes leer el post inicial donde lo presento:

[Roadmap 2026. Test Architecture: 12 meses de aprendizaje continuo](https://ignaciops.dev/blog/roadmap-2026-test-architecture-12-meses-de-aprendizaje-continuo/)

El concepto general de aplicar la Arquitectura Hexagonal es: Lograr separar el qu√© se hace del c√≥mo se hace.

## El problema: tests que no escalan

Hoy en d√≠a, uno de los patrones m√°s usados para la automatizaci√≥n de pruebas es Page Object Model (POM). Tomemos el siguiente ejemplo simplificado:

```python
class HomePage:
    def __init__(self, page):
        self.page = page  # ‚Üê Dependencia directa de Playwright
    
    def click_blog_link(self):
        self.page.locator("#blog-link").click()  # ‚Üê Locator hardcoded
```

Para alguien que comienza en automatizaci√≥n, este c√≥digo es v√°lido y funcional. Sin embargo, presenta varios problemas estructurales:

* el Page Object depende directamente de Playwright,
* los selectores est√°n embebidos dentro de la l√≥gica.

A corto plazo esto no es un problema. Pero conforme el n√∫mero de pruebas crece, empiezan a aparecer fricciones: migrar a otra herramienta implica reescribir la mayor√≠a de los Page Objects; un cambio en un selector obliga a buscar y modificar m√∫ltiples archivos; y, quiz√° m√°s importante, la l√≥gica no puede probarse sin un navegador real.

Esos problemas pueden mitigarse con buenas pr√°cticas dentro de POM, pero cuando el framework crece y los requerimientos del SUT cambian, el patr√≥n deja de ser suficiente como base arquitect√≥nica.

## La propuesta: Arquitectura Hexagonal

A fines de 2025, buscando una forma m√°s robusta de organizar mi c√≥digo de pruebas, decid√≠ aplicar Arquitectura Hexagonal. No como reemplazo de POM, sino como una capa superior que me permitiera desacoplar la l√≥gica de negocio de las herramientas de automatizaci√≥n.

En teor√≠a, esto me permitir√≠a construir un framework m√°s mantenible, m√°s flexible ante cambios de tecnolog√≠a y con la capacidad de probar escenarios sin depender de un entorno E2E completo. En la pr√°ctica, la implementaci√≥n fue menos trivial de lo que esperaba. Conceptos como el Principio de Inversi√≥n de Dependencias y la correcta definici√≥n de contratos tomaron tiempo en ser internalizados antes de reflejarse correctamente en el c√≥digo.

Con esta idea en mente, el siguiente paso fue aterrizar estos conceptos en c√≥digo.

## Aplicaci√≥n: llevando Arquitectura Hexagonal a un framework de pruebas

Quiz√°s recuerdes el diagrama de Arquitectura Hexagonal del post donde expliqu√© lo que aprender√≠a este mes.&#x20;

El siguiente diagrama muestra c√≥mo ese enfoque se aplica a un framework de pruebas: los *Scenarios* viven en el core, dependen √∫nicamente de *Ports*, y  distintos tipos de tests reutilizan la misma l√≥gica cambiando √∫nicamente los *Adapters*.&#x20;

<Mermaid
  code="graph TB
subgraph &#x22;üéØ CORE - Dominio de Testing&#x22;
Scenarios[&#x22;<b>Scenarios</b><br/>(L√≥gica de negocio)<br/>‚Ä¢ NavigationScenario<br/>‚Ä¢ BlogListingScenario<br/>‚Ä¢ CheckoutScenario&#x22;]
Scenarios -.depende de.-> Ports
end

subgraph &#x22;üîå PORTS - Interfaces&#x22;
Ports[&#x22;<b>Ports</b><br/>(Contratos)<br/>‚Ä¢ BrowserPort<br/>‚Ä¢ APIPort<br/>‚Ä¢ DatabasePort&#x22;]
end

subgraph &#x22;üîß ADAPTERS - Implementaciones&#x22;
direction LR
UIAdapters[&#x22;<b>UI Adapters</b><br/>‚Ä¢ PlaywrightAdapter<br/>‚Ä¢ SeleniumAdapter<br/>‚Ä¢ AppiumAdapter&#x22;]
APIAdapters[&#x22;<b>API Adapters</b><br/>‚Ä¢ HTTPXAdapter<br/>‚Ä¢ RequestsAdapter<br/>‚Ä¢ GraphQLAdapter&#x22;]
DataAdapters[&#x22;<b>Data Adapters</b><br/>‚Ä¢ PostgresAdapter<br/>‚Ä¢ MongoAdapter<br/>‚Ä¢ FakeDataAdapter&#x22;]
FakeAdapters[&#x22;<b>Fake Adapters</b><br/>‚Ä¢ FakeBrowserAdapter<br/>‚Ä¢ FakeAPIAdapter<br/>‚Ä¢ InMemoryAdapter&#x22;]
end

subgraph &#x22;üß™ TESTS - Casos de Uso&#x22;
E2ETests[&#x22;<b>E2E Tests</b><br/>Playwright + Real API&#x22;]
EdgeTests[&#x22;<b>Edge-to-Edge</b><br/>Fake Browser + Real API&#x22;]
UnitTests[&#x22;<b>Unit Tests</b><br/>All Fakes&#x22;]
end

Ports -.implementado por.-> UIAdapters
Ports -.implementado por.-> APIAdapters
Ports -.implementado por.-> DataAdapters
Ports -.implementado por.-> FakeAdapters

E2ETests -->|usa| Scenarios
EdgeTests -->|usa| Scenarios
UnitTests -->|usa| Scenarios

UIAdapters -.interact√∫a con.-> Browser[&#x22;üåê Browser Real&#x22;]
APIAdapters -.interact√∫a con.-> API[&#x22;üîó API Real&#x22;]
DataAdapters -.interact√∫a con.-> DB[&#x22;üíæ Database Real&#x22;]
FakeAdapters -.simula en.-> Memory[&#x22;üß† Memoria&#x22;]

style Scenarios fill:#e1f5e1
style Ports fill:#fff4e1
style UIAdapters fill:#e1f0ff
style APIAdapters fill:#e1f0ff
style DataAdapters fill:#e1f0ff
style FakeAdapters fill:#ffe1f0
style E2ETests fill:#f0e1ff
style EdgeTests fill:#f0e1ff
style UnitTests fill:#f0e1ff"
  caption="Figura 1. Arquitectura Hexagonal aplicado a un framework de pruebas"
/>

Si pensamos en un framework de pruebas como una aplicaci√≥n que interact√∫a con una p√°gina web, el diagrama anterior sirve como mapa para entender donde vive cada responsabilidad. Con eso en mente, entonces podr√≠amos definir el Port como la interface que determina c√≥mo nos comunicaremos con la p√°gina usando un navegador. El `BrowserPort`entonces va a determinar qu√© interacciones son posibles mediante el navegador.&#x20;

Para ello tendremos una clase `BrowserPort`que tendr√° m√©todos como Click, o Navigate to, pero sin espec√≠ficar c√≥mo se hace, ya que eso no le interesa al Port, ese es trabajo del adapter. En el caso de Python, nos valdremos de Abstract Base Class (ABC) para la creaci√≥n de esta Interfaz formal.

```python
from abc import ABC, abstractmethod

class BrowserPort(ABC):    
    @abstractmethod
    def click(self, locator: str) -> None:
        """Hacer click en un elemento"""
        pass
```

Por ejemplo, `BrowserPort`determina que se puede hacer clicks en elementos, pero no le interesa el c√≥mo se hace. En otras palabras, el Port es el contrato de capacidades para en este caso espec√≠fico, usar un navegador para interactuar con la p√°gina web. Al hacerlo de esta manera estamos aplicando el Repository Pattern, que nos permite tener separaci√≥n de responsabilidades.

### Scenarios como lenguaje del negocio, no del framework

Ahora, hablemos de los Scenarios. Los scenarios nos muestran la intenci√≥n que hay detr√°s de las acciones del usuario al utilizar el SUT. Escribir los m√©todos con nombres que reflejen qu√© quiere hacer el usuario hace que el c√≥digo deje claro qu√© hace el usuario y qu√© espera al usar la p√°gina web.&#x20;

Un ejemplo sencillo de qu√© se espera ver en un Scenario:

* `HomePageScenario.verify_featured_post_is_shown()`: **Lenguaje de negocio** vs.
* `page.locator('[data-testid="featured-post"]').is_visible()`: **Implementaci√≥n**

Un Scenario no conoce las herramientas que se est√°n utilizando, el Scenario sabe la manera en que el usuario interact√∫a con la p√°gina web porque entiende las capacidades otorgadas por el Port. Podr√≠amos decir que **es el n√∫cleo del dominio de pruebas**. Aqu√≠ es donde encontraremos la l√≥gica del negocio. La ventaja de separar la l√≥gica del negocio con la l√≥gica de pruebas la podemos encontrar en el siguiente ejemplo:

```python
def get_all_post_titles(self) -> list[str]:
    """
    Obtiene los titulos de todos los posts listados en la p√°gina de blog.

    Returns:
        list[str]: Lista de titulos en el orden en que aparecen.
    """
    return self._browser.get_all_nested_texts(
      self.post_card.postCardContainer,
      self.post_card.postCardTitle
    )
```

La funci√≥n `get_all_nested_texts`es una capacidad definida en el Port. El Scenario no sabe si us√© Playwright, WebDriver IO, o Selenium. Solo sabe que tiene la capacidad de obtener todos los textos anidados porque el Port le permite hacerlo.&#x20;

### Inyecci√≥n de dependencias usando fixtures

En este punto pudiera surgir la pregunta, ¬øQu√© pasa si en un test case necesito interactuar con diferentes Scenarios para probar un flujo E2E? En el caso espec√≠fico de Pytest nos valemos de los fixtures. Los fixtures en pytest son funciones decoradas que se utilizan para tener un entorno consistente al momento de ejecutar pruebas. Al ser reutilizables y modulares, son ideales para implementar la Arquitectura Hexagonal porque no necesitamos crear instancias directas de los Scenarios.

```python
import pytest

@pytest.fixture
def browser_port(page: Page) -> PlaywrightBrowserAdapter:
  """
  Fixture que provee la implementacion concreta del BrowserPort.
  """
  return PlaywrightBrowserAdapter(page)

@pytest.fixture
def navigation_scenario(browser_port) -> NavigationScenario:
  """
  Fixture que provee el scenario con la dependencia inyectada.
  """
  return NavigationScenario(browser_port)
```

En el ejemplo anterior tenemos el fixture `browser_port` que retorna el adaptador de Playwright que usa las capacidades definidas por BrowserPort. Ahora, el fixture de `navigation_scenario` nos permitir√° realizar las acciones de la l√≥gica del negocio usando el Adapter de Playwright. Si el pr√≥ximo mes decido agregar Selenium como Adapter, solo necesito agregar los fixtures correspondientes y podr√© ejecutar mis pruebas sin necesidad de estar modificando Scenarios. La l√≥gica de negocio se mantiene, solo cambia la herramienta usada.

### Cuando no necesitas un navegador para probar un escenario

Quiz√° de lo m√°s destacable que aprend√≠ este primer mes fue la teor√≠a introducida en el cap√≠tulo 4 del libro Architecture Patterns with Python. Ah√≠ se habl√≥ del Service Layer para tener una separaci√≥n de responsabilidades y c√≥mo en diferentes sistemas, es utilizado para mantener contenida la l√≥gica del negocio, y que permit√≠a tener tests que pudieran probar esa l√≥gica con datos que se guarden en memoria.&#x20;

En el caso del framework de pruebas esto abri√≥ una posibilidad: **Poder simular interacci√≥n con mi blog mediante fakes**. ¬øY qu√© valor tiene eso? Bueno, cuando decid√≠ probar ese aprendizaje del libro (ojo, que no estaba en el plan original del roadmap) tuve que crear `FakeBrowserAdapter`este Adapter tiene paridad de m√©todos con el Browser Port. Despu√©s de agregar los tests correspondientes, 6 en este caso, al ejecutarlos me llev√© una sorpresa. **Solo 0.02 segundos de tiempo de ejecuci√≥n**.

Dado que este Adapter trabaja con un DOM simulado del Blog, toda la informaci√≥n est√° disponible en memoria, no es necesario levantar un navegador. Todo esto fue posible por la clara separaci√≥n entre Qu√© se puede hacer del C√≥mo se hace.

### Probar estados l√≠mite sin pagar el costo de E2E reales

¬øQu√© tipo de pruebas son las que se hicieron con `FakeBrowserAdapter`? Architecture Patterns with Python introduce un concepto que fue nuevo para mi: Tests `edge-to-edge` estos tests son tests que prueban c√≥mo el framework responde ante Errores de √çndice, Excepciones y otras fallas que se puedan encontrar en el SUT. ¬øLos errores son los esperados? ¬øEsa excepci√≥n es la correcta? Ese tipo de preguntas se contestan al ejecutar este tipo de tests. Por ejemplo, este es el fixture usado para simular que no tengo posts en mi blog:

```python
@pytest.fixture
def fake_browser_empty():
    """
    FakeBrowserAdapter sin posts (blog vac√≠o).
    """
    dom_state = {
        BlogPageLocators.blogPageTitle: {
            "text": "Blog",
            "visible": True
        },
        PostCardLocators.postCardContainer: {
          "count": 0,
          "visible": True
        },
        f"structured_data:{PostCardLocators.postCardContainer}": []
        # No hay post cards
    }

    return FakeBrowserAdapter(dom_state)
```

De esta manera, simulo ese raro caso en que no hay contenido en la p√°gina Home. La ventaja de utilizar el Adapter Fake es que al no levantar el navegador, se pueden ejecutar este tipo de pruebas en milisegundos, permiten determinar qu√© tan resiliente y confiable es el framework de pruebas al interactuar con el SUT.&#x20;

Pero sobre todo, permiten evitar caer en la trampa de querer tener pruebas E2E que intentan validar cada rinc√≥n del SUT en lugar de enfocarse en los casos de uso reales. Esto no significa eliminar la necesidad de tests E2E reales; estamos redefiniendo cu√°ndo y por qu√© usarlos.&#x20;

Algo importante a recordar es que, independientemente de la corriente de pensamiento sobre estrategias de testing, las pruebas E2E siempre deber√≠an ser num√©ricamente menores. La implementaci√≥n Fake nos ayudar√° a cumplir con ese objetivo.

### Documentar decisiones no es un h√°bito autom√°tico

Algo adicional que vale la pena comentar, es que en este proyecto estoy buscando aprender no solo de c√≥digo, sino tambi√©n de c√≥mo se deben ir tomando decisiones importantes para el desarrollo de un sistema. En este caso, empec√© a crear documentaci√≥n, espec√≠ficamente Decisiones Arquitect√≥nicas Registradas (ADRs). Cada decisi√≥n "importante" se ha registrado en su archivo individual. Al momento, para el mes de enero registr√© tres decisiones importantes:

1. Selecci√≥n de Arquitectura Hexagonal como patr√≥n arquitect√≥nico para el framework de pruebas.
2. Convenci√≥n para nombrar locators en el c√≥digo.
3. Agrupar locators que aparecen en diferentes lugar del Blog en archivos comunes.

Probablemente sean pocos ADRs tomando en cuenta lo que se implement√≥. Los ADRs relacionados con locators nacieron como resultado de tener un est√°ndar a lo largo del repositorio. Aunque el Blog es un SUT simple y peque√±o, tener este tipo de decisiones documentadas son bastante valiosas en proyectos m√°s grandes y complejos, permitiendo tener un registro de por qu√© se hacen las cosas de cierta u otra manera.

En caso de que est√©s interesado en conocer el razonamiento usado y c√≥mo se implementaron esas decisiones, puedes revisar el README.md en la carpeta de documentos en el repositorio.&#x20;

[https://github.com/ignaciops/test-architecture-learning/blob/main/docs/architecture/README.md](https://github.com/ignaciops/test-architecture-learning/blob/main/docs/architecture/README.md)

Este proceso de documentaci√≥n tambi√©n expuso otra realidad: aprender el patr√≥n no es un proceso lineal.

## Aprender el patr√≥n requiere fricci√≥n

Es muy f√°cil decir que el c√≥digo dentro de Arquitectura Hexagonal separa el Qu√© se hace del C√≥mo se hace. Pero en la pr√°ctica, tom√≥ varias semanas el que pudiera internalizar esa separaci√≥n. Y sobre todo, dejar de lado la costumbre de "yo escribo mi c√≥digo de esta manera". Todav√≠a estos d√≠as pasados cuando estaba implementando las funciones para un Scenario, ca√≠a en utilizar funciones de Playwright en vez de las capacidades establecidas por el Port.&#x20;

Pero ahora que enero est√° por finalizar, soy consciente al momento de escribir una l√≠nea de c√≥digo en este proyecto. La auto-pregunta constante de "¬øesto rompe la separaci√≥n?" me acompa√±a. Y aunque desear√≠a que lo pudiera hacer de manera autom√°tica, al menos me permite estar al tanto de que el c√≥digo que escribo refleje esa filosof√≠a.

Y sobre todo, no todo lo bueno viene de los *happy paths*. Los beneficios que v√≠ de la aplicaci√≥n de los principios de service layer y los tests edge-to-edge me ayud√≥ a abrir el panorama de c√≥mo se pueden probar las cosas. Esa capacidad de tener feedback r√°pido de c√≥mo reacciona el sistema aporta tranquilidad de que el framework funciona hasta cierto punto, como se espera.&#x20;

## Costo inicial vs simplicidad del SUT

Ahora, no todo es miel sobre ojuelas. La realidad es que para un blog simple como el m√≠o, aplicar Arquitectura Hexagonal al framework de pruebas es un *overengineering* brutal. Probablemente dediqu√© m√°s tiempo a tener las bases del framework que el tiempo dedicado a crear el Blog. Sin embargo, para un Framework de pruebas que soportar√° m√∫ltiples SUTs a lo largo de 12 meses y que necesitar√° capacidades de interactuar con APIs, probar rendimiento, contratos y otras cosas m√°s parece ser una inversi√≥n razonable. As√≠ que si has le√≠do hasta este punto, te invito a volver para el mes de julio, donde har√© una retrospectiva de mitad de a√±o para ver si vali√≥ la pena la implementaci√≥n o no.

Otro punto a tener en cuenta, es que implementar Fake Adapters no es algo sencillo. Para empezar, el Adapter debe tener paridad de m√©todos con el Port. Pero quiz√°s la mayor inversi√≥n que se le dedica a la implementaci√≥n es la complejidad conceptual que implica crear un Fake. En el caso del Blog, era necesario simular el estado del DOM, por ejemplo, ¬øQu√© pasa al hacer click en un link de navegaci√≥n? ¬øC√≥mo se simula esa acci√≥n para tenerla en memoria? Ese tipo de cosas me tom√≥ tiempo el entender c√≥mo hacerlo e implementarlo. Para un sistema con reglas complejas, la inversi√≥n de tiempo para tener Fakes es razonable.

### El principio es reutilizable, la arquitectura no siempre

La realidad es que uno de los `pain points`de muchos patrones para pruebas E2E y de UI automatizadas tiene que ver por no tener una buena separaci√≥n del Qu√© se hace del C√≥mo se hace. Yo he visto de primera mano buenas implementaciones de Page Object Model donde se logra una buena abstracci√≥n y separaci√≥n de la l√≥gica del negocio de la l√≥gica de las pruebas. No es algo tan com√∫n, pero existe. Obviamente cada patr√≥n tiene sus pro y sus contras, pero el principio detr√°s de la Arquitectura Hexagonal y otros patrones de arquitectura de software sigue siendo v√°lido

## Cerrando Enero

Dejando de lado el c√≥digo, creo que lo que m√°s ha cambiado ha sido mi mentalidad. Enfocarme en mejorar me ha llevado a que mi enfoque cambie de: Necesito un "framework que funcione" a un "sistema que puede evolucionar" es con lo que me he quedado.&#x20;

Trabajar con ese enfoque, permite que los sistemas y proyectos futuros empiecen con una base s√≥lida, pensando en el futuro: mi futuro yo que tendr√° que mantener el sistema, mis futuros colaboradores que tendr√°n que tocar mi c√≥digo, mis futuros usuarios que tendr√°n confianza en la herramienta que les estoy proveyendo.&#x20;

Probablemente si empezara Enero otra vez, simplificar√≠a la implementaci√≥n de algunas herramientas, como el Fake Adapter. Me esforzar√≠a por documentar cosas que vayan surgiendo adicionalmente al roadmap de aprendizaje (para que quede claro que es un nice-to-have y un extra). Pero sobre todo, no pensar que si algo parece f√°cil, ser√° f√°cil implementarlo. No me confiar√© nuevamente en ese aspecto.

Febrero me espera con APIs, FastAPI, Testcontainers y la siguiente capa de abstracci√≥n. Nos vemos el pr√≥ximo mes.

---

Si quieres seguir el progreso o contactarme, encu√©ntrame en:&#x20;

* Repositorio: [GitHub](https://github.com/ignaciops/test-architecture-learning)
* LinkedIn: [ignaciops](https://www.linkedin.com/in/ignaciops/)
* Twitter/X: [@ignaciopsdev](https://x.com/ignaciopsdev)
